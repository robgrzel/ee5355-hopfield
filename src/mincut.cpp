#include <vector>
#include "mincut.hpp"
#include "hopfield.hpp"
#include <assert.h>
#include <iostream>
#include "utils.hpp"
#include <chrono>
/*
 * Just returns the last node of the graph
 *
 *
 * Need to revisit to see if any particular choice
 * would lead to better convergence
 *
 */
unsigned MinCutGraph::pickStation() {
   return weights.size()-1;
}

/*
 * The thresholds would simply be the edge weights
 * from the station to all other nodes
 *
 * TODO: Is a deepcopy required?
 */
std::vector<float> MinCutGraph::generateThresholds(unsigned station) {
    std::vector<float> thresholds = weights[station];
    thresholds.erase(thresholds.begin() + station);
    return thresholds;
}


/*
 * This method generates weight matrix of the hopfield network
 * given station
 *
 * The result is generated by omitting row and column corresponding to
 * station
 *
 * station between 
 */
std::vector<std::vector<float> > MinCutGraph::generateWeights(unsigned station) {
    /*
     * Must deepcopy
     * Assignment does deepcopy by itself
     */
    std::vector<std::vector<float> > hopfieldW = weights;
    hopfieldW.erase(hopfieldW.begin() + station);
    for (unsigned i = 0; i < hopfieldW.size(); i++)
        hopfieldW[i].erase(hopfieldW[i].begin() + station);
    return hopfieldW;
}

/*
 *
 *
 *
 */
unsigned MinCutGraph::mapToGraphIndex(unsigned station, unsigned hopfieldIndex) {
    return (hopfieldIndex < station) ? hopfieldIndex : hopfieldIndex+1;
}

/*
 * Make sure that minCutIndex != station
 *
 */
unsigned MinCutGraph::mapToHopfieldIndex(unsigned station, unsigned graphIndex) {
    assert(graphIndex != station);
    return (graphIndex < station) ? graphIndex : graphIndex-1;
}

/*
 * the hopfield network omits station
 *
 */
std::vector<bool> MinCutGraph::generateInitialStates() {
    unsigned size = weights.size()-1;
    std::vector<bool> states(size);
    for (unsigned i = 0; i < size; i++) {
        states[i] = (rand() % 2 > 0) ? true : false;
    }
    return states;
}

/*
 * 
 * 
 */
std::vector<std::vector<unsigned> > MinCutGraph::partitionGraph(Evaluation *const evaluationImpl) {
    unsigned station = pickStation();
    std::vector<std::vector<float> > hopfieldW = generateWeights(station);
    std::vector<float> thresholds = generateThresholds(station);

    /*std::cout << "\nhopfield weights:\n";
    printVector(hopfieldW);
    std::cout << "\nhopfield thresholds:\n";
    printVector(thresholds);*/
    
    HopfieldNetwork* network = evaluationImpl->makeHopfieldNetwork(thresholds, hopfieldW);

    std::vector<bool> initialStates = generateInitialStates();
    /*std::cout << "\ninitial states:\n";
    printVector(initialStates);*/

    auto t1 = std::chrono::high_resolution_clock::now();
    std::vector<bool> states = network->evaluate(initialStates);    
    auto t2 = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = t2 - t1;
    std::cerr << diff.count() << " ker sec\n";

    std::vector<std::vector<unsigned> > partitions;
    partitions.push_back(std::vector<unsigned>());
    partitions.push_back(std::vector<unsigned>());

    for (unsigned i = 0; i < states.size(); i++) {
        unsigned id = mapToGraphIndex(station, i);
        if (states[i]) partitions[1].push_back(id);
        else partitions[0].push_back(id);
    }
    
    //station to false --> weights to thresholds
    //station to true --> weights to -thresholds
    partitions[0].push_back(station);

    delete network;
    
    return partitions;
}

MinCutGraph::MinCutGraph(unsigned numVertices) {
    weights.resize(numVertices, std::vector<float>(numVertices, 0));
    for (unsigned i = 0; i < numVertices; i++) {
        for (unsigned j = i+1; j < numVertices; j++) {
            float val = static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
            if (rand() % 2 > 0) 
                val = -val;
            weights[i][j] = val;
            weights[j][i] = val;
        }
    }

    /*unsigned i = 0;
    while (i < numVertices*(numVertices-1)/4) {
        unsigned x = rand() % numVertices;
        unsigned y = rand() % numVertices;
        if (weights[x][y] != 0) {
            weights[x][y] = weights[y][x] = 0;
            i++;
        }
    }*/
}

std::vector<std::vector<float> > MinCutGraph::getWeights() {
    return weights;
}
