#include <vector>
#include "mincut.hpp"

/*
 * Just returns the last node of the graph
 *
 *
 * Need to revisit to see if any particular choice
 * would lead to better convergence
 *
 */
unsigned MinCutGraph::pickStation() {
    return rowOffsets.size()-2;
}

/*
 * The thresholds would simply be the edge weights
 * from the station to all other nodes
 *
 * TODO: Is a deepcopy required?????????????????????????????????????
 */
std::vector<float> MinCutGraph::generateThresholds(unsigned station) {
    return weights[station];
}


/*
 * This method generates weight matrix of the hopfield network
 * given station
 *
 * The result is generated by omitting row and column corresponding to
 * station
 *
 * station between 
 */
std::vector<std::vector<float> > MinCutGraph::generateWeights(unsigned station) {
    /*
     * Must deepcopy!
     *
     */
    std::vector<std::vector<float> > hopfieldW = weights;
    hopfieldW.erase(hopfieldW.begin() + station);

    for (unsigned i = 0; i < )
    return hopfieldW;
}


/*
 *
 *
 *
 */
unsigned MinCutGraph::mapToGraphIndex(unsigned station, unsigned hopfieldIndex) {
    return (hopfieldIndex < station) ? hopfieldIndex : hopfieldIndex+1;
}

/*
 * Make sure that minCutIndex != station!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 */
unsigned MinCutGraph::mapToHopfieldIndex(unsigned station, unsigned minCutIndex) {
    return (minCutIndex < station) ? minCutIndex : minCutIndex-1;
}

/*
 * the hopfield network omits station
 * so rowOffsets.size()-1 is the size
 *
 */
std::vector<bool> MinCutGraph::generateInitialStates() {
    unsigned size = rowOffsets.size()-2;
    std::vector<bool> states(size);
    for (unsigned i = 0; i < size; i++) {
        states.push_back(false);
    }
}
